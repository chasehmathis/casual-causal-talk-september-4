---
title: "Demo Simulating Data Casual Causal"
output: html_document
date: "`r Sys.Date()`"
author: "Your name"
---
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
knitr::opts_chunk$set(eval = FALSE)
```

## Walk Through

\begin{align}
X &\sim N(0,1)\\
Z \mid X &\sim \rm{Bernoulli}(\operatorname{expit}(X))\\
Y_{Z} &\sim N(Z, 1)
\end{align}

and we will have a Gaussian Copula between $X$ and $Y$ with parameter $\rho = 2\operatorname{expit}(0.4) - 1$

```{r}
# need gcc
remotes::install_github("chasehmathis/causl")
remotes::install_github("chasehmathis/survivl")
library(causl)
library(survivl)
```

```{r setup-1}
# define the "structure" of the causal model
forms <- 
  list(
    # (covariates),
    # (Treatments | covariates),
    # (Marginal Causal),
    # Copula
  )
print(causl::family_vals)
# translate Normal, Bernoulli, etc.
fams <- 
  list(
    # (covariates)
    # (Treatments | covariates),
    # (Marginal Causal),
    # copula
  )

# The paramters for this model
pars <- 
  list(
    # (covariates)
    # (Treatments | covariates),
    # (Marginal Causal),
    # copula
  )

# make a causal model object
cm <- causl_model(formulas = forms, family = fams, pars = pars)

# curious about the link functions?
print(cm$link)

# simualte from this model
dat <- rfrugal(n = 1e3, causl_model = cm)
```

```{r ipw estimator, eval = FALSE}
ps <- fitted(glm(Z ~ X, family = binomial(), data = dat))
wts <- dat$Z/ps + (1-dat$Z)/(1-ps)
library(survey) # recommend this for estimated weight s.e.

design <- svydesign(~1, weights = wts, data = dat)
mod <- svyglm(Y ~ Z, design = design)

summary(mod)
```

## Plasmode Example

Plasmode means to simulate on top of existing data. Suppose you want to run an experiment on students in the Berkeley statistics department assigning them to either come into Evans hall or stay home to work. An interesting outcome could be time till graduation (we'll return to this), but an easier one is their dat grade average at the end of the year (continuous, normal assumption). For returning students we have their grades from last year, otherwise we have 1st year students grades from their last school. We have this information it is fixed and not random. Say, we want to assign treatment conditional on that.

```{r}
# assume we have last years grades of n = 100 students, call it X
n <- 100
X <- grade_average <- pmin(rnorm(n, 91, 3), 100)
# mean center
X <- X - mean(X)
dat0 <- data.frame(X)
```

```{r}
# define the "structure" of the causal model
forms <- 
  list(
    # (covariates),
    # (Treatments | covariates),
    # (Marginal Causal),
    # Copula
  )
print(causl::family_vals)
# translate Normal, Bernoulli, etc.
fams <- 
  list(
    # (covariates)
    # (Treatments | covariates),
    # (Marginal Causal),
    # copula
  )

# The paramters for this model
pars <- 
  list(
    # (covariates)
    # (Treatments | covariates),
    # (Marginal Causal),
    # copula
  )

# make a causal model object
cm <- causl_model(formulas = forms, family = fams, pars = pars)

# curious about the link functions?
print(cm$link)

# simualte from this model
dat <- rfrugal(n = 1e3, causl_model = cm)
```

## Using Plasmode for Treatment Switching

In this vignette we consider *marginal structural models* for *non*-time-to-event data. Begin by loading the library.

We follow the situation as researched in Bodnar et al. (2004), which examines the causal effect of iron supplement use during pregancy on the odds of anemia at delivery. Therefore, we have a longitudinal data structure with one, non survival outcome. We have time varying covariates as treatment is not fixed and hemoglobin levels dictate further treatment assignments.

The baseline covariates are $Z$ which is the set {B = pre-pregnancy obesity, C = age}. $L$ is our single time varying covariate: Hemoglobin levels. The outcome $Y$ is a binary {0,1} indicating anemia at delivery.

We set at $t = 0$, $B \sim \rm{Bernoulli}(0.1), C \sim U(25, 35), L_0 \sim N(11−0.05 B−0.02 C, 0.5)$ and $A_0 \sim \rm{Bernoulli}(0.5)$.

For $k > 0$, we have $L_k \sim N(L_{k−1} + 0.5 A_{k−1}, 0.1)$, $A_0 = A_1 = A_2$ and $A_k \sim \rm{Bernoulli}(\rm{expit}(10 - L_k + 0.1A_{k-1})$ for $k = 3,4$.

Our structural causal model is

$$\PM(Y(\bar{A_k}) = 1 \mid  B, C) = \rm{expit}(-2 + 0.1B + 0.02C - \beta \sum_{j = 1}^{4}A_j))$$

### Simulate t = 0, 1, 2

Here, we set up the number of samples and our quantiles data frame. Note that we assume $A_k$ is the same for $k = 0,1,2$, so the quantiles for those variables are set to be the same.

```{r}
# t = 0, n = 10,000
n <- 1e4
qtls <- data.frame(matrix(runif(n*4), ncol = 4))
colnames(qtls) <- c("B", "C", "L_0", "A_0") # this is different than previous. 
# We have access to quantiles/ranks
qtls <- cbind(qtls, qtls[["A_0"]], qtls[["A_0"]])
colnames(qtls) <- c("B", "C", "L_0", "A_0", "A_1", "A_2")
```

Now we use the inverse cdf to get random samples from our quantiles. We collect them in `dat0` variable.

```{r}
B <- qbinom(qtls[["B"]], 1, 0.1);  C <- qunif(qtls[["C"]], 25, 35)
L_0 <- qnorm(qtls[["L_0"]], 11 - 0.05 * B - 0.02 * C, 0.5)
A_0 <- A_1 <- A_2 <- qbinom(qtls[["A_0"]], 1, 0.5)

dat0 <- cbind(B, C, L_0, A_0, A_1, A_2)

```

This code chunk sets up our `surv_model` object by defining the structur and parameters we imposed above.

```{r}
forms <- list(list(B ~ 1, C ~ 1),
              L ~ B + C,
              A ~ L_l0 + A_l1,
              Y ~ B + C + I(A_0 + A_1 + A_2 + A_3 + A_4),
              L ~ 1)
fams <- list(list(5, 4),
             1,
             5,
             5,
             2)
causal_parameters <- c(-2, 0.1, 0.02, -0.5)
pars <- list(
  B = list(beta = 0.1), 
  C = list(beta = 1),
  L = list(beta = c(11, -0.05, -0.02), phi = 0.5),
  A = list(beta = c(10, -1, 0.1)),
  Y = list(beta = causal_parameters),
  cop = list(Y = list(L = list(beta = 0.4, par2 = 5))))

surv_model <- survivl_model(formulas = forms, family = fams,
                            pars = pars, T = 5, dat = dat0, qtls = qtls)
```

We call `rmsm` to simulate from this model.

```{r}
dat <- rmsm(n, surv_model)
```

Now, we choose to use the IPW estimator to recover our estimates we specified.

```{r}

glm_A0 <- glm(A_0 ~ L_0, family = binomial(), data = dat)
glm_A3 <- glm(A_3 ~ L_0 + L_1 + L_2 + A_0 , family = binomial(), data = dat)
glm_A4 <- glm(A_4 ~ L_0 + L_1 + L_2 + L_3 + A_0  + A_3, family = binomial(), data = dat)

glm_A0_num <- glm(A_0 ~ 1, family = binomial(), data = dat)
glm_A3_num <- glm(A_3 ~ A_0, family = binomial(), data = dat)
glm_A4_num <- glm(A_4 ~ A_0 + A_3, family = binomial(), data = dat)

ps_A0_num <- predict(glm_A0_num, type = "response")
ps_A3_num <- predict(glm_A3_num, type = "response")
ps_A4_num <- predict(glm_A4_num, type = "response")

ps_A0 <- predict(glm_A0, type = "response")
ps_A3 <- predict(glm_A3, type = "response")
ps_A4 <- predict(glm_A4, type = "response")

# Compute weights depending on actual values of X_t
w0 <- ifelse(dat$A_0 == 1, ps_A0, 1 - ps_A0)
w1 <- w2 <- rep(1,n) #  always 1 because A_1 and A_2 are deterministic conditional on A_0
w3 <- ifelse(dat$A_3 == 1, ps_A3, 1 - ps_A3)
w4 <- ifelse(dat$A_4 == 1, ps_A4, 1 - ps_A4)
w0_num <- ifelse(dat$A_0 == 1, ps_A0_num, 1 - ps_A0_num)
w3_num <- ifelse(dat$A_3 == 1, ps_A3_num, 1 - ps_A3_num)
w4_num <- ifelse(dat$A_4 == 1, ps_A4_num, 1 - ps_A4_num)

dat$iptw_weights <- w0_num * w3_num * w4_num / (w0 * w1 * w2 * w3 * w4 )

glm_Y <- glm(Y ~ B + C + I(A_0 + A_1 + A_2 + A_3 + A_4), 
             data = dat, weights = iptw_weights, family = binomial())
```

```{r}
sumY <- summary(glm_Y)
abs(sumY$coefficients[,1] - causal_parameters)/sumY$coefficients[,2]
# should be less than 2 s.e. 95% of the time
```

## Survival Outcome Example

In the previous example, we had one $Y$ at the end of the study. To code it you use the  survivl package, even though it is not a survival event. Our method does allow
for survival events (also known as time-to-event outcomes). Examples include
time until graduation or time until death. Data is hard and includes many caveats
including censoring.


Then we define our formulas and family variables. We will have one
baseline variable, and a single time-varying covariate, treatment and
outcome. More specifically, let: \begin{align*}
W &\sim \operatorname{Gamma}(1/2, \, 2)  \\
X_t \mid \overline{X}_{t-1}, \overline{Z}_{t-1} &\sim N(0.7 X_{t-1} + 0.2 Z_{t-1}, \, 1)\\
Z_t \mid \overline{X}_{t}, \overline{Z}_{t-1} &\sim \operatorname{Bernoulli}(\operatorname{expit}(0.5 Z_{t-1} + 0.25 X_t))\\ 
P(Y_t(\overline{Z}_{t}) = 1 \mid  W) &= \exp\{ - 0.2 Z_t + W/10\},
\end{align*} and assume that there is a Gaussian pair-copula linking
$Y_t$ with $X_{t-1},X_t$, which also depends upon $W$. 

```{r formulas}
forms <- list(W ~ 1,
              X ~ X_l1 + Z_l1,
              Z ~ Z_l1 + X_l0,
              Y ~ W + Z_l0,
              list(Y = list(X~W)))
fams <- list(3, 1, 5, 3, c(1))
pars <- list(W = list(beta=0, phi=1/2),
             X = list(beta=c(0,0.7,0.2), phi=1),
             Z = list(beta=c(-0.5,0.25,0.5)),
             Y = list(beta=c(1,-1/10,1/5), phi=1),
             cop = list(Y=list(X=list(beta = c(0,0.5)))))

link <- list("log", "identity", "logit", "log")
surv_model <- survivl_model(T = 8, formulas = forms, family = fams, pars = pars, link=link)
```

```{r simulate from the surv_model}
n <- 1e3
dat <- rmsm(n, surv_model)
datl <- surv_to_long(dat, lag=1)

library(ipw)
library(survival)
temp <- ipwtm(
  exposure = Z,
  family = "binomial",
  link = "logit",
  numerator = ~ W,
  denominator = ~ W + X,
  id = id,
  type = "all",
  timevar = t,
  data = datl,
)
datl$wt <- temp$ipw.weights
# can do a cox model or survey::survreg does parametric
mod_correct <- coxph(Surv(t, t_stop, Y) ~W + Z, weights = wt, data = datl,
                     timefix = FALSE) 
mod_naive <- coxph(Surv(t, t_stop, Y) ~ W + Z, weights = rep(1, nrow(datl)), data = datl,
                   timefix = FALSE)
```


## Power Calculation Example

All of these parts of the model will stay the same when we do our power calculations.

```{r define static model}
formulas <- list(list(C ~ 1,
                      X ~ C),
         Z ~ X + C,
         Y ~ Z + C,
         list(Y = list(X ~1)))
family <- list(c(5,1),5,1,1) # binomial, normal, binomial, normal, normal
link <- list(list("logit", "identity"), "logit", "identity")
pars <- list(C = list(beta=0),
             X = list(beta = c(-1/2,0.25), phi=0.5),
             Z = list(beta = c(0,1/2,1/10)),
             cop = list(Y = list(Z = list(beta=0.8472979), 
                                 C = list(beta = 0)))) 
```

However, our causal effect will change as we plot our power curve.

Create a function to estimate power for a specific causal effect and alpha = 0.05

```{r}
monte_carlo_sims <- 1e3
estimate_power <- function(causal_effect, n = 1e3, alpha = 0.05){
  pars[["Y"]] <- list(beta = c(0, causal_effect, 0.2), phi = 1)
  cm <- causl_model(formulas = formulas, family = family, 
                    link = link, pars = pars)
  pvals <- numeric(length = monte_carlo_sims)
  covered <- numeric(length = monte_carlo_sims)
  for(i in seq(monte_carlo_sims)){
    dat <- rfrugal(n, causl_model  = cm)
    wts <- ipw::ipwpoint(exposure = Z, family = "binomial", link = "logit",
                         numerator = ~C, denominator = ~C +X,
                         data = dat)$ipw.weights
    sumMod <- summary(lm(Y ~ X + C, weights = wts, data = dat))
    pvals[i] <- sumMod$coefficients[2,4]
    covered[i] <-  (abs(sumMod$coefficients[2,1] - causal_effect) / sumMod$coefficients[2,2]) < 2
  }
  return(list(pvals = pvals, covered = covered, n = n, causal_effect = causal_effect))
}

causal_effects <- seq(0.05, 0.25, length.out = 10)
ns <- c(2e2, 4e2, 6e2, 8e2, 1e3)
grid <- expand.grid(causal_effect = causal_effects, n = ns)


```

```{r, eval=FALSE}
# takes a long time to run. Change eval=TRUE to run.
res <- apply(grid, 1, \(x) estimate_power(x[1], x[2]))
res2 <- lapply(res, \(x) list(pvals = x$pvals, covered = x$covered, 
                             n = x$n, causal_effect = x$causal_effect))


```

```{r, eval=FALSE}
# takes a long time to run. Change eval=TRUE to run.
power <- sapply(res, function(x) mean(x$pvals < 0.05))
coverage <- sapply(res, function(x) mean(x$covered))
ns <- sapply(res, function(x) x$n)
causal_effects <- sapply(res, function(x) x$causal_effect)
results <- data.frame(
  causal_effect = causal_effects,
  power = power,
  coverage = coverage,
  ns = factor(ns),
  causal_effects = causal_effects
)
results |> 
  ggplot(aes(x = causal_effects, y = power, color = ns)) + 
  geom_line() +
  geom_point() + 
  labs(
    x = "Causal Effect",
    y = "Power = 1 - Type II error Rate",
    title = "Power by (n) and causal effect"
  )

results |> 
  ggplot(aes(x = causal_effect, y = coverage, color = ns)) + 
    geom_line() +
  geom_point() + 
  ylim(c(0.9,1)) + 
  labs(
    x = "Causal Effect",
    y = "Coverage",
    title = "2 Standard Error Coverage by (n) and causal effect"
  )
  
```
